{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Figurate is a framework for building robust, scalable and modular Java applications. Figurate is based on the principles of modularity, testability and adaptability, which provide the basis for a platform that is capable of supporting the processes that underpin many of the modern design and implementation strategies. Modularity As software projects evolve and mature they become more and more complex, leading to issues of maintainability and comprehension. Often the design of many aspects of software is only fully understood by those that implement it. Modularity ensures that software components are small enough to be understood by newcomers, resulting in an increased maintainability, irregardless of how complex the software project is as a whole. Additionally, modularity provides the opportunity to replaces individual software components as the need arises without needing to rework the entire platform. Often there is a need to alter the integration points of a platform (e.g. datasources, external services, etc.), or even to support multiple different integrations points concurrently. Either scenario is well-supported by a modular approach, whereby a configuration change is all that is required. Testability The quality of software is often in direct correlation to the amount of testing performed on it. Testing modular software components allows more targeted and thorough testing of the features specific to the component. In addition, where a Design by Contract approach is applied, testing provides verification that a component conforms to the required contracts. Adaptability Often the final implementation of a software project is quite different to that which was envisaged prior to implementation. Throughout the development process many changes may occur, both in architecture and underlying technologies. A modular design supports these anticipated changes by allowing multiple different architectural and technological designs.","title":"Introduction"},{"location":"#introduction","text":"Figurate is a framework for building robust, scalable and modular Java applications. Figurate is based on the principles of modularity, testability and adaptability, which provide the basis for a platform that is capable of supporting the processes that underpin many of the modern design and implementation strategies.","title":"Introduction"},{"location":"#modularity","text":"As software projects evolve and mature they become more and more complex, leading to issues of maintainability and comprehension. Often the design of many aspects of software is only fully understood by those that implement it. Modularity ensures that software components are small enough to be understood by newcomers, resulting in an increased maintainability, irregardless of how complex the software project is as a whole. Additionally, modularity provides the opportunity to replaces individual software components as the need arises without needing to rework the entire platform. Often there is a need to alter the integration points of a platform (e.g. datasources, external services, etc.), or even to support multiple different integrations points concurrently. Either scenario is well-supported by a modular approach, whereby a configuration change is all that is required.","title":"Modularity"},{"location":"#testability","text":"The quality of software is often in direct correlation to the amount of testing performed on it. Testing modular software components allows more targeted and thorough testing of the features specific to the component. In addition, where a Design by Contract approach is applied, testing provides verification that a component conforms to the required contracts.","title":"Testability"},{"location":"#adaptability","text":"Often the final implementation of a software project is quite different to that which was envisaged prior to implementation. Throughout the development process many changes may occur, both in architecture and underlying technologies. A modular design supports these anticipated changes by allowing multiple different architectural and technological designs.","title":"Adaptability"},{"location":"iac/","text":"Infrastructure as Code Cloud platforms are the cornerstone of a revolution in how we manage infrastructure. The ability to provision just-in-time infrastructure programmatically means that we are now able to \"program\" our infrastructure requirements to meet immediate and future needs. Infrastructure as code is the tooling and languages that allow us to interact with IaaS, PaaS and Saas Cloud platforms to provision and manage infrastructure. Blueprints Infrastructure as code (IaC) blueprints provide common, reusable code that may be used in multiple architectures. Blueprints provide a number of benefits. Abstraction They allow us to abstract the details specific to a platform or environment such that we only need to configure the instance-specific details. Portability By using higher-level constructs like blueprints to compose architectures we also inherently improve the portability of an architecture, both within and across different platforms. Blueprint-based architectures are more easily replicated in different environments as they are easier to duplicate. (*) (*) Some blueprints may not be replicable across all platforms, but generally Cloud concepts are transferable across multiple platforms. Defaults We can use blueprints to provide sensible defaults as applicable to platforms and environments we manage. Governance Blueprints provde a way to enforce standards and governance around aspects such as security, cost and availability.","title":"Overview"},{"location":"iac/#infrastructure-as-code","text":"Cloud platforms are the cornerstone of a revolution in how we manage infrastructure. The ability to provision just-in-time infrastructure programmatically means that we are now able to \"program\" our infrastructure requirements to meet immediate and future needs. Infrastructure as code is the tooling and languages that allow us to interact with IaaS, PaaS and Saas Cloud platforms to provision and manage infrastructure.","title":"Infrastructure as Code"},{"location":"iac/#blueprints","text":"Infrastructure as code (IaC) blueprints provide common, reusable code that may be used in multiple architectures. Blueprints provide a number of benefits.","title":"Blueprints"},{"location":"iac/#abstraction","text":"They allow us to abstract the details specific to a platform or environment such that we only need to configure the instance-specific details.","title":"Abstraction"},{"location":"iac/#portability","text":"By using higher-level constructs like blueprints to compose architectures we also inherently improve the portability of an architecture, both within and across different platforms. Blueprint-based architectures are more easily replicated in different environments as they are easier to duplicate. (*) (*) Some blueprints may not be replicable across all platforms, but generally Cloud concepts are transferable across multiple platforms.","title":"Portability"},{"location":"iac/#defaults","text":"We can use blueprints to provide sensible defaults as applicable to platforms and environments we manage.","title":"Defaults"},{"location":"iac/#governance","text":"Blueprints provde a way to enforce standards and governance around aspects such as security, cost and availability.","title":"Governance"},{"location":"iac/terraform/","text":"Introduction Terraform is an infrastructure provisioning tool that defines a language that allows for declarative definition of infrastructure resources in a concise format. The power of Terraform is in the extensive list of provider plugins that implement integration with multiple Cloud platforms and vendor services. Pros The primary benefit of Terraform is that it is the default standard for integration with major Cloud providers, such that many of the new platform features are available first in Terraform. Strong Open Source community supporting multiple provider implementations for major and niche platforms and services. Extensible to support custom provider implementations to suit most needs Concise language well suited to infrastructure definition Cons Terraform alone is usually not sufficient to provide a complete Infrastructure as Code solution, but can be the cornerstone in a broader strategy. Infrastructure state is not managed automatically (Terraform Cloud does improve this) Some values may be stored in state insecurely (e.g. secrets, credentials, etc.) Module Guidelines Figurate modules are developed with the following principles for maximum portability and reuse. Use consistent variable names where possible (use same convention as resources) Make no assumptions about provider and backend configuration (these are configured externally) Avoid nested modules (minimise externally managed dependencies) Make no assumptions about execution environment (avoid local-exec)","title":"Introduction"},{"location":"iac/terraform/#introduction","text":"Terraform is an infrastructure provisioning tool that defines a language that allows for declarative definition of infrastructure resources in a concise format. The power of Terraform is in the extensive list of provider plugins that implement integration with multiple Cloud platforms and vendor services.","title":"Introduction"},{"location":"iac/terraform/#pros","text":"The primary benefit of Terraform is that it is the default standard for integration with major Cloud providers, such that many of the new platform features are available first in Terraform. Strong Open Source community supporting multiple provider implementations for major and niche platforms and services. Extensible to support custom provider implementations to suit most needs Concise language well suited to infrastructure definition","title":"Pros"},{"location":"iac/terraform/#cons","text":"Terraform alone is usually not sufficient to provide a complete Infrastructure as Code solution, but can be the cornerstone in a broader strategy. Infrastructure state is not managed automatically (Terraform Cloud does improve this) Some values may be stored in state insecurely (e.g. secrets, credentials, etc.)","title":"Cons"},{"location":"iac/terraform/#module-guidelines","text":"Figurate modules are developed with the following principles for maximum portability and reuse. Use consistent variable names where possible (use same convention as resources) Make no assumptions about provider and backend configuration (these are configured externally) Avoid nested modules (minimise externally managed dependencies) Make no assumptions about execution environment (avoid local-exec)","title":"Module Guidelines"},{"location":"iac/terraform/aws/","text":"Amazon Web Services (AWS) Support for AWS in Terraform is probably greater than any other platform. The modules below look at providing standard modules for common AWS components. Identity and Access Management (IAM) IAM manages roles and permissions for human and programmatic access to resources. IAM Permissions TBD. IAM Role TBD. IAM User TBD. Elastic Cloud Compute (EC2) EC2 is the cornerstone of compute infrastructure in AWS. As such there are a number of useful blueprints we can define that are applicable for reuse across many architectures. Launch Template TBD. Load Balancer TBD. Spot Fleet TBD. Elastic Container Registry (ECR) ECR provides storage for container images used across different container platforms. ECR Repository TBD. Elastic Container Service (ECS) ECS is a native AWS container platform that provides tight integration with the AWS platform. Capacity Provider TBD. Task Definition TBD.","title":"AWS"},{"location":"iac/terraform/aws/#amazon-web-services-aws","text":"Support for AWS in Terraform is probably greater than any other platform. The modules below look at providing standard modules for common AWS components.","title":"Amazon Web Services (AWS)"},{"location":"iac/terraform/aws/#identity-and-access-management-iam","text":"IAM manages roles and permissions for human and programmatic access to resources.","title":"Identity and Access Management (IAM)"},{"location":"iac/terraform/aws/#iam-permissions","text":"TBD.","title":"IAM Permissions"},{"location":"iac/terraform/aws/#iam-role","text":"TBD.","title":"IAM Role"},{"location":"iac/terraform/aws/#iam-user","text":"TBD.","title":"IAM User"},{"location":"iac/terraform/aws/#elastic-cloud-compute-ec2","text":"EC2 is the cornerstone of compute infrastructure in AWS. As such there are a number of useful blueprints we can define that are applicable for reuse across many architectures.","title":"Elastic Cloud Compute (EC2)"},{"location":"iac/terraform/aws/#launch-template","text":"TBD.","title":"Launch Template"},{"location":"iac/terraform/aws/#load-balancer","text":"TBD.","title":"Load Balancer"},{"location":"iac/terraform/aws/#spot-fleet","text":"TBD.","title":"Spot Fleet"},{"location":"iac/terraform/aws/#elastic-container-registry-ecr","text":"ECR provides storage for container images used across different container platforms.","title":"Elastic Container Registry (ECR)"},{"location":"iac/terraform/aws/#ecr-repository","text":"TBD.","title":"ECR Repository"},{"location":"iac/terraform/aws/#elastic-container-service-ecs","text":"ECS is a native AWS container platform that provides tight integration with the AWS platform.","title":"Elastic Container Service (ECS)"},{"location":"iac/terraform/aws/#capacity-provider","text":"TBD.","title":"Capacity Provider"},{"location":"iac/terraform/aws/#task-definition","text":"TBD.","title":"Task Definition"},{"location":"iac/terraform/digitalocean/","text":"Digital Ocean","title":"Digital Ocean"},{"location":"iac/terraform/digitalocean/#digital-ocean","text":"","title":"Digital Ocean"},{"location":"iac/terraform/modules/","text":"The following table provides information about available Terraform modules. Module Description Source Build Status AWS ECR Repository Github AWS IAM Role Github","title":"Modules"},{"location":"modularity/","text":"Modular Architectures Application architectures must continually evolve and grow not only to meet future needs but to stay relevant and secure in an ecosystem that is continually changing. Because of the need for constant growth a monolithic architecture will eventually become very difficult to maintain in both size and complexity. For this reason modular architectures make more sense for even the smallest applications to be able to not only manage components independently, but to allow for upgrade and replacement of different components over time.","title":"Overview"},{"location":"modularity/#modular-architectures","text":"Application architectures must continually evolve and grow not only to meet future needs but to stay relevant and secure in an ecosystem that is continually changing. Because of the need for constant growth a monolithic architecture will eventually become very difficult to maintain in both size and complexity. For this reason modular architectures make more sense for even the smallest applications to be able to not only manage components independently, but to allow for upgrade and replacement of different components over time.","title":"Modular Architectures"},{"location":"modularity/docker/","text":"Docker Docker is the most popular incarnation of the Container-as-a-Service (CaaS) application model, whereby applications are packaged and executed in isolated containers. Docker is extremely versatile in that it supports any language or application that runs on Linux, resulting modern applications that can be designed as a collection of modular containers that integrate to form robust and easy to maintain architectures.","title":"Introduction"},{"location":"modularity/docker/#docker","text":"Docker is the most popular incarnation of the Container-as-a-Service (CaaS) application model, whereby applications are packaged and executed in isolated containers. Docker is extremely versatile in that it supports any language or application that runs on Linux, resulting modern applications that can be designed as a collection of modular containers that integrate to form robust and easy to maintain architectures.","title":"Docker"},{"location":"modularity/lambda/","text":"Lambda AWS Lambda is the most popular implementation of Function as a service (FaaS), whereby loosely-coupled functions are deployed and managed independently. The primary benefit of Lambda is that there are no hosts that need patching and maintenance, allowing the DevOps team to focus entirely on the application (function) code.","title":"Introduction"},{"location":"modularity/lambda/#lambda","text":"AWS Lambda is the most popular implementation of Function as a service (FaaS), whereby loosely-coupled functions are deployed and managed independently. The primary benefit of Lambda is that there are no hosts that need patching and maintenance, allowing the DevOps team to focus entirely on the application (function) code.","title":"Lambda"},{"location":"modularity/osgi/","text":"Introduction The Open Services Gateway Initiative (OSGi) is a plugin architecture for composing Java applications. OSGi is an \"in-process\" approach to modularity such that components share the same application memory, etc. Pros The benefits of an in-process modular architecture like OSGi typically relate to performance and security concerns. In-process communication is more efficient than out-of-process Less need for authentication/encryption of inter-component communication Cons Whilst OSGi may be considered as a modular architecture it is still a more tightly-coupled approach than out-of-process architectures. Restricted to Java-based components that can run in-process Whilst theoretically can replace/upgrade components at run-time, still requires redeploy for major changes","title":"Introduction"},{"location":"modularity/osgi/#introduction","text":"The Open Services Gateway Initiative (OSGi) is a plugin architecture for composing Java applications. OSGi is an \"in-process\" approach to modularity such that components share the same application memory, etc.","title":"Introduction"},{"location":"modularity/osgi/#pros","text":"The benefits of an in-process modular architecture like OSGi typically relate to performance and security concerns. In-process communication is more efficient than out-of-process Less need for authentication/encryption of inter-component communication","title":"Pros"},{"location":"modularity/osgi/#cons","text":"Whilst OSGi may be considered as a modular architecture it is still a more tightly-coupled approach than out-of-process architectures. Restricted to Java-based components that can run in-process Whilst theoretically can replace/upgrade components at run-time, still requires redeploy for major changes","title":"Cons"},{"location":"modularity/osgi/getting-started/","text":"Getting Started The Figurate Guide provides documentation to assist with getting the most out of the Figurate framework. Getting Started Launcher Components Constellations Getting Started The following instructions will help you to get a Figurate project up and running as quickly as possible. Gradle Plugin The simplest way to use Figurate is to apply the Figurate plugin in a Gradle build script. Some example applications are provided that demonstrate usage of this plugin. Launcher The Figurate Launcher is a convenient way to configure the bootstrap of the underlying OSGi platform. Startup Configuration Bundles Start Levels Components Figurate provides configuration via the OSGi standard Configuration Admin support. Component Configuration Factory Configuration Constellations A Figurate Constellation is a collection of bundles that are designed to work together to provide a specific feature. The available Figurate constellations are as follows: | Constellation | Figurate Versions | Description |- | felix | All | Felix OSGi runtime | http | All | HTTP server/Servlet container (Jetty) | scr | All | Service Component Runtime | webconsole | All | Felix OSGi dashboard Gradle Plugin Figurate provides a gradle plugin to make it simple to add constellations to your application, without needing to worry about compatibility issues between bundles across different constellations. You apply the constellation plugin as follows: apply plugin: 'constellations' Configurations The Gradle Constellation Plugin uses Gradle configurations to define constellations. As such, to add a constellation to your application you just include the configuration in Figurate's custom bundle configuration, like so: bundle constellation$felix You can also make use of Gradle's dependency tools to query the actual bundles included in a given constellation: gradle dependencies --configuration constellation\\$felix Note that as Figurate constellations are defined using a dollar ($) symbol, some shells may try to apply variable substitution, which is why we need to escape the dollar. The output should look something like this: {% highlight bash %} \\$ gradle dependencies --configuration constellation\\$felix :feed-aggregator:dependencies Project :feed-aggregator constellation$felix +--- org.apache.felix:org.apache.felix.dependencymanager:4.0.1 +--- org.apache.felix:org.apache.felix.http.bundle:2.2.2 +--- org.apache.felix:org.apache.felix.log:1.0.1 +--- org.apache.felix:org.apache.felix.scr:1.8.2 +--- org.osgi:org.osgi.compendium:4.2.0 --- org.apache.felix:org.apache.felix.configadmin:1.8.0 BUILD SUCCESSFUL Total time: 6.027 secs {% endhighlight %}","title":"Getting Started"},{"location":"modularity/osgi/getting-started/#getting-started","text":"The Figurate Guide provides documentation to assist with getting the most out of the Figurate framework. Getting Started Launcher Components Constellations","title":"Getting Started"},{"location":"modularity/osgi/getting-started/#getting-started_1","text":"The following instructions will help you to get a Figurate project up and running as quickly as possible.","title":"Getting Started"},{"location":"modularity/osgi/getting-started/#gradle-plugin","text":"The simplest way to use Figurate is to apply the Figurate plugin in a Gradle build script. Some example applications are provided that demonstrate usage of this plugin.","title":"Gradle Plugin"},{"location":"modularity/osgi/getting-started/#launcher","text":"The Figurate Launcher is a convenient way to configure the bootstrap of the underlying OSGi platform.","title":"Launcher"},{"location":"modularity/osgi/getting-started/#startup-configuration","text":"","title":"Startup Configuration"},{"location":"modularity/osgi/getting-started/#bundles","text":"","title":"Bundles"},{"location":"modularity/osgi/getting-started/#start-levels","text":"","title":"Start Levels"},{"location":"modularity/osgi/getting-started/#components","text":"Figurate provides configuration via the OSGi standard Configuration Admin support.","title":"Components"},{"location":"modularity/osgi/getting-started/#component-configuration","text":"","title":"Component Configuration"},{"location":"modularity/osgi/getting-started/#factory-configuration","text":"","title":"Factory Configuration"},{"location":"modularity/osgi/getting-started/#constellations","text":"A Figurate Constellation is a collection of bundles that are designed to work together to provide a specific feature. The available Figurate constellations are as follows: | Constellation | Figurate Versions | Description |- | felix | All | Felix OSGi runtime | http | All | HTTP server/Servlet container (Jetty) | scr | All | Service Component Runtime | webconsole | All | Felix OSGi dashboard","title":"Constellations"},{"location":"modularity/osgi/getting-started/#gradle-plugin_1","text":"Figurate provides a gradle plugin to make it simple to add constellations to your application, without needing to worry about compatibility issues between bundles across different constellations. You apply the constellation plugin as follows: apply plugin: 'constellations'","title":"Gradle Plugin"},{"location":"modularity/osgi/getting-started/#configurations","text":"The Gradle Constellation Plugin uses Gradle configurations to define constellations. As such, to add a constellation to your application you just include the configuration in Figurate's custom bundle configuration, like so: bundle constellation$felix You can also make use of Gradle's dependency tools to query the actual bundles included in a given constellation: gradle dependencies --configuration constellation\\$felix Note that as Figurate constellations are defined using a dollar ($) symbol, some shells may try to apply variable substitution, which is why we need to escape the dollar. The output should look something like this: {% highlight bash %} \\$ gradle dependencies --configuration constellation\\$felix :feed-aggregator:dependencies","title":"Configurations"},{"location":"modularity/osgi/getting-started/#project-feed-aggregator","text":"constellation$felix +--- org.apache.felix:org.apache.felix.dependencymanager:4.0.1 +--- org.apache.felix:org.apache.felix.http.bundle:2.2.2 +--- org.apache.felix:org.apache.felix.log:1.0.1 +--- org.apache.felix:org.apache.felix.scr:1.8.2 +--- org.osgi:org.osgi.compendium:4.2.0 --- org.apache.felix:org.apache.felix.configadmin:1.8.0 BUILD SUCCESSFUL Total time: 6.027 secs {% endhighlight %}","title":"Project :feed-aggregator"},{"location":"modularity/osgi/release-notes/","text":"figurate-core","title":"Release Notes"},{"location":"orchestration/","text":"Orchestration Orchestration is the higher level coordination of automated tasks that define a process. Whilst we can automate infrastructure provisioning and deployment of modular architectures, orchestration defines the processes required to ensure these tasks are performed in a safe and orderly fashion.","title":"Overview"},{"location":"orchestration/#orchestration","text":"Orchestration is the higher level coordination of automated tasks that define a process. Whilst we can automate infrastructure provisioning and deployment of modular architectures, orchestration defines the processes required to ensure these tasks are performed in a safe and orderly fashion.","title":"Orchestration"},{"location":"orchestration/gradle/","text":"Gradle Whilst Gradle is technically not an Orchestration tool, the extensive suite of plugins means that it is quite a versatile tool that can be used as part of an orchestrated process.","title":"Overview"},{"location":"orchestration/gradle/#gradle","text":"Whilst Gradle is technically not an Orchestration tool, the extensive suite of plugins means that it is quite a versatile tool that can be used as part of an orchestrated process.","title":"Gradle"}]}